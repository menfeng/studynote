Chapter 13. Copy Control
复制构造函数、赋值操作符和析构函数总称为复制控制
13.1. The Copy Constructor
只有单个形参，而且该形参是对本类类型对象的引用（常用 const 修饰），这样的构造函数称为复制构造函数（复制构造函数的形参并不限制为 const，但必须是一个引用，否则会导致复制构造函数的无穷递归），用处
（1）根据另一个同类型的对象显式或隐式初始化一个对象
（2）作为实参，作为返回值。
（3）初始化容器，数组          
        容器：vector<string> svec(5);//调用默认构造函数，然后调用复制构造函数
        数组：CMyClass   a[]={1,CMyClass()};   想利用传递一个参数的构造，就可直接传参数；如果不传参，或多个参，就应传完整构造函数
                   上面的数组分别调用了普通构造函数和默认构造函数并未调用复制构造函数
1*Forms of Object Definition
*直接初始化和复制初始化。复制初始化使用 = 符号，而直接初始化将初始化式放在圆括号中。
*当用于类类型对象时，初始化的复制形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，复制初始化总是调用复制构造函数。
注意：CMyClass my=1;//CMyClass 有一个接受int的构造函数
（1）当接受int 的构造函数为非explicit才正确
（2）若（1）成立，此处仅仅调用此构造函数，不会调用复制构造函数，这正是primer中“当情况许可时，可以允许编译器跳过复制构造函数直接创建对象，但编译器没有义务这样做。”的体现
13.1.1. The Synthesized Copy Constructor 
与合成的默认构造函数不同，即使！！我们定义了其他构造函数，也会合成复制构造函数。
合成复制构造函数的行为是，执行逐个成员初始化，将新对象初始化为原对象的副本。类类型成员使用该类的复制构造函数进行复制。数组成员，则合成复制构造函数将复制数组。复制数组时合成复制构造函数将复制数组的每一个元素。
13.1.2. Defining Our Own Copy Constructor   
Copy Constructor   一般不应设置为 explicit，像其他任何构造函数一样，如果没有初始化某个类成员，则那个成员用该成员的默认构造函数初始化。复制构造函数中的默认初始化不会使用成员的复制构造函数。
13.1.3. Preventing Copies
为了防止复制，类必须显式声明其复制构造函数为 private。如果想要连友元和成员中的复制也禁止，就可以声明一个（private）复制构造函数但不对其定义。声明而不定义成员函数是合法的，但是，使用未定义成员的任何尝试将导致链接失败
Most Classes Should Define Copy and Default Constructors
不允许复制的类对象只能作为引用传递给函数或从函数返回，它们也不能用作容器的元素。如果定义了复制构造函数，也必须定义默认构造函数（因为此时不会合成默认构造函数了）


13.2. The Assignment Operator 
如果类没有定义自己的赋值操作符，则编译器会合成一个。
1*Introducing Overloaded Assignment
重载操作符是一些函数，形参表必须具有与该操作符数目相同的形参（如果操作符是一个类成员，第一个操作数隐式绑定到 this 指针）。
赋值是二元运算，必须是类的成员，受单个形参，一般作为 const 引用传递。内置类型的赋值运算返回对右操作数的引用，因此，赋值操作符也返回对同一类类型的引用。

2*The Synthesized Assignment Operator
合成赋值操作符会执行逐个成员赋值，该操作符返回 *this
Copy and Assign Usually Go Together
可以使用合成复制构造函数的类通常也可以使用合成赋值操作符，实际上，就将这两个操作符看作一个单元。如果需要其中一个，我们几乎也肯定需要另一个

13.3. The Destructor 
撤销一个容器（不管是标准库容器还是内置数组）时，也会运行容器中的类类型元素的析构函数：容器中的元素总是按逆序撤销：首先撤销下标为 size() - 1 的元素
1*When to Write an Explicit Destructor
析构函数通常用于释放在构造函数或在对象生命期内获取的资源。如果类需要析构函数，则它也需要赋值操作符和复制构造函数，这是一个有用的经验法则
2*The Synthesized Destructor
合成析构函数按对象创建时的逆序撤销每个非 static 成员，因此，它按成员在类中声明次序的逆序撤销成员
3*How to Write a Destructor
一个代字号（~），它没有返回值，没有形参。因为不能指定任何形参，所以不能重载析构函数
即使我们编写了自己的析构函数，合成析构函数仍然运行；先运行自己的析构函数再运行合成的析构减函数
如果析构函数为，private或protected那么无法运行delete p；
13.4. A Message-Handling Example

13.5. Managing Pointer Members 
大多数 C++ 类采用以下三种方法之一管理指针成员：
1*指针成员采取常规指针型行为。这样的类具有指针的所有缺陷但无需特殊的复制控制
2*类可以实现所谓的“智能指针”行为。指针所指向的对象是共享的，但类能够防止悬垂指针。
3*类采取值型行为。指针所指向的对象是唯一的，由每个类对象独立管理。
13.5.1. Defining Smart Pointer Classes
1*Introducing Use Counts
定义智能指针的通用技术是采用一个使用计数，也称为引用计数。
2*The Use-Count Class
实现使用计数有两种经典策略，在这里将使用其中一种，另一种方法在第 15.8.1 节中讲述。这里所用的方法中，需要定义一个单独的具体类用以封闭使用计数和相关指针：
&&&智能指针总结：若类A有一个M类型的指针成员，那么我们将增加一个使用计数类USE，在USE中，有使用计数和M*，指向M的实例，而A中的M*换做USE*，并将A设为USE的友元，进而实现复制控制
3*13.5.2. Defining Valuelike Classes
13.5.2. Defining Valuelike Classes
复制构造：分配新空间，并将值复制到此空间
赋值：直接对两空间的值进行复制
&&&讨论：
（1）仅仅没有定义赋值：A=A1后，A中原有类存泄露！！！，A1撤消后，A中有野指针，A再撤销导致指针二次删除
（2）仅仅每有定义析构：每次撤销对象会导致内存泄露
（3）仅仅定义析构：除了（1）中赋值问题，当然还有复制构造导致类似的问题










